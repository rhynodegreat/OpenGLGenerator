using System;
using System.IO;
using System.Text;
using System.Collections.Generic;

using OpenGLGenerator;

namespace GeneratorTest {
    public class CSGenerator {
        Spec spec;
        Dictionary<string, Command> commandMap;
        HashSet<string> includedEnums;
        List<Command> includedCommands;
        List<Group> includedGroups;
        Dictionary<string, string> groupShim;

        public CSGenerator(Spec spec) {
            this.spec = spec;
            commandMap = new Dictionary<string, Command>();
            includedEnums = new HashSet<string>();
            includedCommands = new List<Command>();
            includedGroups = new List<Group>();
            groupShim = new Dictionary<string, string>();
        }

        public void Generate() {
            Patch();
            ResolveFeatures("gl", "core");
            DateTime now = DateTime.Now;
            if (!Directory.Exists("output")) Directory.CreateDirectory("output");
            using (var writer = File.CreateText("output/enums.cs")) {
                writer.WriteLine("//autogenerated on {0}", now.ToString());
                GenerateEnums(writer);
            }

            using (var writer = File.CreateText("output/delegates.cs")) {
                writer.WriteLine("//autogenerated on {0}", now.ToString());
                GenerateDelegates(writer);
            }

            using (var writer = File.CreateText("output/loader.cs")) {
                writer.WriteLine("//autogenerated on {0}", now.ToString());
                GenerateLoader(writer, "gl", 4, 5, "core");
            }

                Console.WriteLine("Done generating");
        }

        void GenerateEnums(StreamWriter writer) {
            HashSet<string> written = new HashSet<string>();
            writer.WriteLine("namespace OpenGL {");

            foreach (var group in includedGroups) {
                bool write = false;
                foreach (var enumName in group.EnumNames) {
                    if (includedEnums.Contains(enumName)) {
                        write = true;
                        break;
                    }
                }

                if (write) {
                    string name = group.Name;
                    if (groupShim.ContainsKey(name)) name = groupShim[name];
                    if (written.Contains(name)) continue;

                    writer.WriteLine($"    public enum {name} : uint {{");
                    foreach (var enumName in group.EnumNames) {
                        if (spec.EnumMap.ContainsKey(enumName) && includedEnums.Contains(enumName)) {
                            OpenGLGenerator.Enum e = spec.EnumMap[enumName];
                            writer.WriteLine($"        {ToCamelCase(enumName)} = {e.Value},");
                        }
                    }
                    writer.WriteLine("    }");
                    writer.WriteLine();
                    written.Add(name);
                }
            }

            writer.WriteLine("}");
        }

        void GenerateDelegates(StreamWriter writer) {
            writer.WriteLine("using System;");
            writer.WriteLine();
            writer.WriteLine("namespace OpenGL {");
            writer.WriteLine("    public static class GL {");
            foreach (var c in includedCommands) {
                string returnType = GetReturnType(c.ReturnType, c);
                string name = GetName(c.Name);
                writer.Write("        public delegate {0} {1}Delegate(", returnType, name);
                for (int i = 0; i < c.Parameters.Count; i++) {
                    var p = c.Parameters[i];
                    string pName = GetName(p.Name);
                    string pType = GetParamType(p.Type, p);

                    if (groupShim.ContainsKey(pType)) pType = groupShim[pType];

                    writer.Write("{0} {1}", pType, pName);
                    if (i < c.Parameters.Count - 1) {
                        writer.Write(", ");
                    }
                }
                writer.WriteLine(");");
                writer.WriteLine("        public static {0}Delegate {0};", name);
                writer.WriteLine();
            }
            writer.WriteLine("    }");
            writer.WriteLine("}");
        }

        void GenerateLoader(StreamWriter writer, string api, int major, int minor, string profile) {
            List<Command> commands = new List<Command>();
            GetCommands(commands, api, major, minor, profile);
            commands.Sort((Command a, Command b) => a.Name.CompareTo(b.Name));
            string template = File.ReadAllText("loader.cs");
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < commands.Count; i++) {
                builder.Append('"');
                builder.Append(commands[i].Name);
                builder.Append('"');
                if (i < commands.Count - 1) builder.Append(",\r\n                ");
            }
            string nameArray = builder.ToString();
            
            writer.Write(string.Format(template, api.ToUpper(), major, minor, profile, nameArray));
        }

        void ResolveFeatures(string api, string profile) {
            foreach (var g in spec.Groups) includedGroups.Add(g);

            foreach (var fs in spec.Features) {
                if (!(fs.API == api)) continue;
                foreach (var fl in fs.Lists) {
                    if (!(fl.Profile == null || fl.Profile == profile)) continue;
                    foreach (var f in fl.List) {
                        if (fl.Action == "require") {
                            if (f.Type == FeatureType.Command) {
                                if (!commandMap.ContainsKey(f.Name)) {
                                    commandMap.Add(f.Name, spec.CommandMap[f.Name]);
                                }
                            } else {
                                includedEnums.Add(f.Name);
                            }
                        }
                    }
                }
            }

            foreach (var command in commandMap.Values) {
                includedCommands.Add(command);
            }
            
            includedCommands.Sort((Command a, Command b) => a.Name.CompareTo(b.Name));
        }

        void GetCommands(List<Command> list, string api, int major, int minor, string profile) {
            foreach (var fs in spec.Features) {
                if (!(fs.API == api)) continue;
                foreach (var fl in fs.Lists) {
                    if (!(fl.Profile == null || fl.Profile == profile)) continue;
                    foreach (var f in fl.List) {
                        if (f.Type == FeatureType.Command) {
                            if (fl.Action == "require") {
                                if (!list.Contains(spec.CommandMap[f.Name])) {
                                    list.Add(spec.CommandMap[f.Name]);
                                }
                            } else if (fl.Action == "remove") {
                                if (list.Contains(spec.CommandMap[f.Name])) {
                                    list.Remove(spec.CommandMap[f.Name]);
                                }
                            }
                        }
                    }
                }
            }
        }

        void Patch() {  //some groups are used in the API but are not defined in the <groups> section, they must be added here
            Shim("BlendEquationModeEXT", "BlendEquationMode");  //changes a few names to be more readable
            Shim("BufferTargetARB", "BufferTarget");
            Shim("BlendingFactorSrc", "BlendingFactor");
            Shim("BlendingFactorDest", "BlendingFactor");
            Shim("BlendFuncSeparateParameterEXT", "BlendingFactor");
            Shim("BufferUsageARB", "BufferUsage");
            Shim("ClampColorModeARB", "bool");
            Shim("ClampColorTargetARB", "ClampColorTarget");
            Shim("DrawBufferModeATI", "DrawBufferMode");
            Shim("ColorMaterialFace", "Face");  //these groups are exactly the same, so they all become the same "Face" group
            Shim("MaterialFace", "Face");
            Shim("CullFaceMode", "Face");
            Shim("StencilFaceDirection", "Face");
            Shim("BufferAccessARB", "BufferAccess");
            Shim("PointParameterNameARB", "PointParameterName");
            Shim("BufferPNameARB", "BufferPName");
            Shim("BufferPointerNameARB", "BufferPName");
            Shim("VertexAttribPropertyARB", "VertexAttribProperty");
            Shim("VertexAttribPointerPropertyARB", "VertexAttribPointerProperty");

            PatchGroup("TypeEnum",  //add in missing groups
                "GL_QUERY_WAIT",            
                "GL_QUERY_NO_WAIT",         
                "GL_QUERY_BY_REGION_WAIT",  
                "GL_QUERY_BY_REGION_NO_WAIT"
            );
            PatchGroup("BufferTargetARB",
                "GL_ARRAY_BUFFER",
                "GL_ATOMIC_COUNTER_BUFFER",
                "GL_COPY_READ_BUFFER",
                "GL_COPY_WRITE_BUFFER",
                "GL_DRAW_INDIRECT_BUFFER",
                "GL_DISPATCH_INDIRECT_BUFFER",
                "GL_ELEMENT_ARRAY_BUFFER",
                "GL_PIXEL_PACK_BUFFER",
                "GL_PIXEL_UNPACK_BUFFER",
                "GL_QUERY_BUFFER",
                "GL_SHADER_STORAGE_BUFFER",
                "GL_TEXTURE_BUFFER",
                "GL_TRANSFORM_FEEDBACK_BUFFER",
                "GL_UNIFORM_BUFFER"
            );
            PatchGroup("FramebufferTarget",
                "GL_DRAW_FRAMEBUFFER",
                "GL_READ_FRAMEBUFFER",
                "GL_FRAMEBUFFER"
            );
            PatchGroup("RenderbufferTarget", "GL_RENDERBUFFER");
            PatchGroup("BlendEquationMode",
                "GL_FUNC_ADD",
                "GL_FUNC_SUBTRACT",
                "GL_FUNC_REVERSE_SUBTRACT",
                "GL_MIN",
                "GL_MAX"
            );
            PatchGroup("BufferUsage",
                "GL_STREAM_DRAW",
                "GL_STREAM_READ",
                "GL_STREAM_COPY",
                "GL_STATIC_DRAW",
                "GL_STATIC_READ",
                "GL_STATIC_COPY",
                "GL_DYNAMIC_DRAW",
                "GL_DYNAMIC_READ",
                "GL_DYNAMIC_COPY"
            );
            PatchGroup("ClampColorTarget", "GL_CLAMP_READ_COLOR");
            PatchGroup("DrawElementsType",
                "GL_POINTS",
                "GL_LINE_STRIP",
                "GL_LINE_LOOP",
                "GL_LINES",
                "GL_LINE_STRIP_ADJACENCY",
                "GL_LINES_ADJACENCY",
                "GL_TRIANGLE_STRIP",
                "GL_TRIANGLE_FAN",
                "GL_TRIANGLES",
                "GL_TRIANGLE_STRIP_ADJACENCY",
                "GL_TRIANGLES_ADJACENCY",
                "GL_PATCHES"
            );
            PatchGroup("FramebufferAttachment",
                "GL_COLOR_ATTACHMENT0",
                "GL_COLOR_ATTACHMENT1",
                "GL_COLOR_ATTACHMENT2",
                "GL_COLOR_ATTACHMENT3",
                "GL_COLOR_ATTACHMENT4",
                "GL_COLOR_ATTACHMENT5",
                "GL_COLOR_ATTACHMENT6",
                "GL_COLOR_ATTACHMENT7",
                "GL_COLOR_ATTACHMENT8",
                "GL_COLOR_ATTACHMENT9",
                "GL_COLOR_ATTACHMENT11",
                "GL_COLOR_ATTACHMENT12",
                "GL_COLOR_ATTACHMENT13",
                "GL_COLOR_ATTACHMENT14",
                "GL_COLOR_ATTACHMENT15",
                "GL_COLOR_ATTACHMENT16",
                "GL_COLOR_ATTACHMENT17",
                "GL_COLOR_ATTACHMENT18",
                "GL_COLOR_ATTACHMENT19",
                "GL_COLOR_ATTACHMENT21",
                "GL_COLOR_ATTACHMENT22",
                "GL_COLOR_ATTACHMENT23",
                "GL_COLOR_ATTACHMENT24",
                "GL_COLOR_ATTACHMENT25",
                "GL_COLOR_ATTACHMENT26",
                "GL_COLOR_ATTACHMENT27",
                "GL_COLOR_ATTACHMENT28",
                "GL_COLOR_ATTACHMENT29",
                "GL_COLOR_ATTACHMENT30",
                "GL_COLOR_ATTACHMENT31",
                "GL_DEPTH_ATTACHMENT",
                "GL_STENCIL_ATTACHMENT",
                "GL_DEPTH_STENCIL_ATTACHMENT"
            );
            PatchGroup("TextureUnit",
                "GL_TEXTURE0",
                "GL_TEXTURE1",
                "GL_TEXTURE2",
                "GL_TEXTURE3",
                "GL_TEXTURE4",
                "GL_TEXTURE5",
                "GL_TEXTURE6",
                "GL_TEXTURE7",
                "GL_TEXTURE8",
                "GL_TEXTURE9",
                "GL_TEXTURE10",
                "GL_TEXTURE11",
                "GL_TEXTURE12",
                "GL_TEXTURE13",
                "GL_TEXTURE14",
                "GL_TEXTURE15",
                "GL_TEXTURE16",
                "GL_TEXTURE17",
                "GL_TEXTURE18",
                "GL_TEXTURE19",
                "GL_TEXTURE20",
                "GL_TEXTURE21",
                "GL_TEXTURE22",
                "GL_TEXTURE23",
                "GL_TEXTURE24",
                "GL_TEXTURE25",
                "GL_TEXTURE26",
                "GL_TEXTURE27",
                "GL_TEXTURE28",
                "GL_TEXTURE29",
                "GL_TEXTURE30",
                "GL_TEXTURE31"
            );
            PatchGroup("PixelInternalFormat",
                "GL_COMPRESSED_RGB8_ETC2",
                "GL_COMPRESSED_SRGB8_ETC2",
                "GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",
                "GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",
                "GL_COMPRESSED_RGBA8_ETC2_EAC",
                "GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",
                "GL_COMPRESSED_R11_EAC, GL_COMPRESSED_SIGNED_R11_EAC",
                "GL_COMPRESSED_RG11_EAC",
                "GL_COMPRESSED_SIGNED_RG11_EAC"
            );
            PatchGroup("VertexAttribEnum",
                "GL_BYTE",
                "GL_UNSIGNED_BYTE",
                "GL_SHORT, GL_UNSIGNED_SHORT",
                "GL_INT",
                "GL_UNSIGNED_INT"
            );
            PatchGroup("VertexAttribPointerType",
                "GL_BYTE",
                "GL_UNSIGNED_BYTE",
                "GL_SHORT, GL_UNSIGNED_SHORT",
                "GL_INT",
                "GL_UNSIGNED_INT",
                "GL_HALF_FLOAT",
                "GL_FLOAT",
                "GL_DOUBLE",
                "GL_FIXED",
                "GL_INT_2_10_10_10_REV",
                "GL_UNSIGNED_INT_2_10_10_10_REV",
                "GL_UNSIGNED_INT_10F_11F_11F_REV"
            );
            PatchGroup("Face",
                "GL_BACK",
                "GL_FRONT",
                "GL_FRONT_AND_BACK"
            );
            PatchGroup("BufferAccess",
                "GL_READ_ONLY",
                "GL_WRITE_ONLY",
                "GL_READ_WRITE"
            );
            PatchGroup("PointParameterName",
                "GL_POINT_FADE_THRESHOLD_SIZE",
                "GL_POINT_SPRITE_COORD_ORIGIN"
            );
            PatchGroup("BufferPName",
                "GL_BUFFER_ACCESS",
                "GL_BUFFER_MAPPED",
                "GL_BUFFER_SIZE",
                "GL_BUFFER_USAGE"
            );
            PatchGroup("VertexAttribProperty",
                "VertexAttribPropertyARB",
                "GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
                "GL_VERTEX_ATTRIB_ARRAY_ENABLED",
                "GL_VERTEX_ATTRIB_ARRAY_SIZE",
                "GL_VERTEX_ATTRIB_ARRAY_STRIDE",
                "GL_VERTEX_ATTRIB_ARRAY_TYPE",
                "GL_VERTEX_ATTRIB_ARRAY_NORMALIZED",
                "GL_VERTEX_ATTRIB_ARRAY_INTEGER",
                "GL_VERTEX_ATTRIB_ARRAY_DIVISOR",
                "GL_CURRENT_VERTEX_ATTRIB"
            );
            PatchGroup("ProgramParameterPName",
                "GL_PROGRAM_BINARY_RETRIEVABLE_HINT",
                "GL_PROGRAM_SEPARABLE"
            );
            PatchGroup("GetPointervPName",
                "GL_DEBUG_CALLBACK_FUNCTION",
                "GL_DEBUG_CALLBACK_USER_PARAM"
            );
            PatchGroup("VertexAttribPointerProperty",
                "GL_VERTEX_ATTRIB_ARRAY_POINTER"
            );

            PatchGroup("DebugMessageSource",
                "GL_DEBUG_SOURCE_API",
                "GL_DEBUG_SOURCE_WINDOW_SYSTEM",
                "GL_DEBUG_SOURCE_SHADER_COMPILER",
                "GL_DEBUG_SOURCE_THIRD_PARTY",
                "GL_DEBUG_SOURCE_APPLICATION",
                "GL_DEBUG_SOURCE_OTHER"
            );
            PatchGroup("DebugMessageType",
                "GL_DEBUG_TYPE_ERROR",
                "GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR",
                "GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR",
                "GL_DEBUG_TYPE_PORTABILITY",
                "GL_DEBUG_TYPE_PERFORMANCE",
                "GL_DEBUG_TYPE_MARKER",
                "GL_DEBUG_TYPE_PUSH_GROUP",
                "GL_DEBUG_TYPE_POP_GROUP",
                "GL_DEBUG_TYPE_OTHER"
            );
            PatchGroup("DebugMessageSeverity",
                "GL_DEBUG_SEVERITY_HIGH",
                "GL_DEBUG_SEVERITY_MEDIUM",
                "GL_DEBUG_SEVERITY_LOW",
                "GL_DEBUG_SEVERITY_NOTIFICATION"
            );
        }

        void PatchGroup(string name, params string[] enums) {
            var g = new Group(name);
            includedGroups.Add(g);
            for (int i = 0; i < enums.Length; i++) {
                string eName = enums[i];
                g.EnumNames.Add(eName);
            }
        }

        void Shim(string source, string target) {
            groupShim.Add(source, target);
        }

        string ToCamelCase(string input) {
            var builder = new StringBuilder();
            string[] tokens = input.Split('_');
            for (int i = 1; i < tokens.Length; i++) {
                string token = tokens[i];
                bool first = false;
                if (token.Contains("RG")) { //RG RGB RGBA SRGB
                    builder.Append(token);
                    continue;
                }
                for (int j = 0; j < token.Length; j++) {
                    char c = token[j];
                    if (char.IsDigit(c)) {
                        if (i == 1 && j == 0) {
                            builder.Append('_');
                        }
                        builder.Append(c);
                    } else if (char.IsLetter(c)) {
                        if (!first) {
                            builder.Append(char.ToUpper(c));
                            first = true;
                        } else {
                            builder.Append(char.ToLower(c));
                        }
                    }
                }
            }

            return builder.ToString();
        }

        string GetName(string input) {
            switch (input) {
                case "ref":
                    return "_ref";
                case "params":
                    return "_params";
                case "string":
                    return "_string";
                case "base":
                    return "_base";
                default:
                    return input;
            }
        }

        string GetReturnType(string input, Command command) {
            switch (input) {
                case "GLenum":
                    if (command.ReturnGroup != null) {
                        return command.ReturnGroup;
                    } else {
                        return "uint";
                    }
                case "GLsync":
                    return "IntPtr";
                case "GLfloat":
                    return "float";
                case "GLboolean":
                    return "bool";
                case "GLubyte":
                    return "byte";
                case "GLushort":
                    return "ushort";
                case "GLshort":
                    return "short";
                case "GLint":
                    return "int";
                case "GLuint":
                    return "uint";
                case "GLuint64":
                    return "long";
                case "GLbitfield":
                    return "uint";
                default:
                    return input;
            }
        }

        string GetParamType(string input, Parameter p) {
            switch (input) {
                case "GLint":
                    return "int";
                case "GLuint":
                    return "uint";
                case "GLenum":
                    if (p.Group != null) {
                        return p.Group;
                    } else {
                        return "uint";
                    }
                case "GLfloat":
                    return "float";
                case "GLboolean":
                    return "bool";
                case "GLdouble":
                    return "double";
                case "GLsizei":
                    return "int";
                case "GLsync":
                    return "IntPtr";
                case "GLubyte":
                    return "byte";
                case "GLbyte":
                    return "sbyte";
                case "GLushort":
                    return "ushort";
                case "GLshort":
                    return "short";
                case "GLuint64":
                    return "ulong";
                case "GLint64":
                    return "long";
                case "GLbitfield":
                    return "uint";
                case "GLchar":
                    return "char";
                case "GLintptr":
                    return "IntPtr";
                case "GLsizeiptr":
                    return "int";
                case "void*":
                    return "IntPtr";
                default:
                    return input;
            }
        }
    }
}
