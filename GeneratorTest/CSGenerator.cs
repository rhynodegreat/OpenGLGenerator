using System;
using System.IO;
using System.Text;
using System.Collections.Generic;

using OpenGLGenerator;

namespace GeneratorTest {
    public class CSGenerator {
        CSSpec spec;
        Dictionary<string, string> groupRename;

        //public CSGenerator(Spec spec) {
        //    this.spec = spec;
        //    commandMap = new Dictionary<string, Command>();
        //    includedEnums = new HashSet<string>();
        //    includedCommands = new List<Command>();
        //    includedGroups = new List<Group>();
        //}

        public CSGenerator(CSSpec spec) {
            this.spec = spec;
            groupRename = new Dictionary<string, string>();
        }

        public void Generate() {
            Patch();
            DateTime now = DateTime.Now;
            if (!Directory.Exists("output")) Directory.CreateDirectory("output");
            using (var writer = File.CreateText("output/enums.cs")) {
                writer.WriteLine("//autogenerated on {0}", now.ToString());
                GenerateEnums(writer);
            }

            using (var writer = File.CreateText("output/delegates.cs")) {
                writer.WriteLine("//autogenerated on {0}", now.ToString());
                GenerateDelegates(writer);
            }

            using (var writer = File.CreateText("output/loader.cs")) {
                writer.WriteLine("//autogenerated on {0}", now.ToString());
                GenerateLoader(writer, "gl", 4, 5, "core");
            }

            using (var writer = File.CreateText("output/wrapper.cs")) {
                writer.WriteLine("//autogenerated on {0}", now.ToString());
                GenerateWrapper(writer, "gl", 4, 5, "core");
            }
        }

        void GenerateEnums(StreamWriter writer) {
            writer.WriteLine("namespace OpenGL {");

            HashSet<string> written = new HashSet<string>();

            foreach (var group in spec.Enums) {
                string name = group.Name;
                if (groupRename.ContainsKey(name)) name = groupRename[name];
                if (written.Contains(name)) continue;

                writer.WriteLine($"    public enum {name} : uint {{");
                    for (int i = 0; i < group.Names.Count; i++) {
                    writer.WriteLine("        {0} = {1},", group.Names[i], group.Values[i]);
                }
                writer.WriteLine("    }");
                writer.WriteLine();
                written.Add(name);
            }

            writer.WriteLine("}");
        }

        void GenerateDelegates(StreamWriter writer) {
            int commands = 0;
            writer.WriteLine("using System;");
            writer.WriteLine("using System.Text;");
            writer.WriteLine();
            writer.WriteLine("namespace OpenGL {");
            writer.WriteLine("    public static unsafe class GL {");
            foreach (var c in spec.Commands) {
                string returnType = GetReturnType(c.ReturnType, c);
                string name = c.Name;
                writer.Write("        public delegate {0} {1}Delegate(", returnType, name);
                for (int i = 0; i < c.Parameters.Count; i++) {
                    var p = c.Parameters[i];
                    string pName = GetName(p.Name);
                    string pType = p.Type;

                    if (groupRename.ContainsKey(pType)) {
                        pType = groupRename[pType];
                    }

                    string pre = "";
                    string post = "";

                    if (p.ParamType == ParamType.Out) {
                        pre = "out ";
                    } else if (p.ParamType == ParamType.Ref) {
                        pre = "ref ";
                    } else if (p.ParamType == ParamType.Array) {
                        post = "[]";
                    }

                    writer.Write("{0}{1}{2} {3}", pre, pType, post, pName);
                    if (i < c.Parameters.Count - 1) {
                        writer.Write(", ");
                    }
                }
                writer.WriteLine(");");
                writer.WriteLine("        public static {0}Delegate {0};", name);
                writer.WriteLine();
                commands++;
            }
            writer.WriteLine("    }");
            writer.WriteLine("}");
            Console.WriteLine("{0} commands written", commands);
        }

        void GenerateLoader(StreamWriter writer, string api, int major, int minor, string profile) {
            List<CSCommand> commands = spec.Commands;
            commands.Sort((CSCommand a, CSCommand b) => a.Name.CompareTo(b.Name));
            string template = File.ReadAllText("loader.cs");
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < commands.Count; i++) {
                builder.Append('"');
                builder.Append(commands[i].Name);
                builder.Append('"');
                if (i < commands.Count - 1) builder.Append(",\r\n                ");
            }
            string nameArray = builder.ToString();
            
            writer.Write(string.Format(template, api.ToUpper(), major, minor, profile, nameArray));
            Console.WriteLine("{0} commands in loader", commands.Count);
        }

        void GenerateWrapper(StreamWriter writer, string api, int major, int minor, string profile) {
            List<CSCommand> commands = spec.Commands;

            writer.WriteLine("using System;");
            writer.WriteLine("using System.Text;");
            writer.WriteLine();
            writer.WriteLine("namespace OpenGL.{0}{1}_{2}_{3} {{", api.ToUpper(), major, minor, profile);
            writer.WriteLine("    public static partial class GL {");

            for (int i = 0; i < commands.Count; i++) {
                var c = commands[i];
                string returnType = GetReturnType(c.ReturnType, c);

                writer.Write("        public static");
                writer.Write(" {0} {1}(", returnType, c.Name.Substring(2));
                for (int j = 0; j < c.Parameters.Count; j++) {
                    var p = c.Parameters[j];
                    string pName = GetName(p.Name);
                    string pType = p.Type;

                    if (groupRename.ContainsKey(pType)) pType = groupRename[pType];

                    //if (pType[pType.Length - 1] == '*' && pType != "void*" && pName != "length") {
                    //    pType = pType.Substring(0, pType.Length - 1) + "[]";
                    //}

                    string pre = "";
                    string post = "";

                    if (p.ParamType == ParamType.Out) {
                        pre = "out ";
                    } else if (p.ParamType == ParamType.Ref) {
                        pre = "ref ";
                    } else if (p.ParamType == ParamType.Array) {
                        post = "[]";
                    }

                    writer.Write("{0}{1}{2} {3}", pre, pType, post, pName);
                    if (j < c.Parameters.Count - 1) {
                        writer.Write(", ");
                    }
                }

                writer.WriteLine(") {");
                
                GenerateSimpleWrapper(writer, c);

                writer.WriteLine("        }");
                writer.WriteLine();
            }

            writer.WriteLine("    }\r\n}");
        }

        void GenerateSimpleWrapper(StreamWriter writer, CSCommand c) {
            writer.Write("            ");
            if (c.ReturnType != "void") writer.Write("return ");
            writer.Write("{0}(", c.Name);

            for (int j = 0; j < c.Parameters.Count; j++) {
                var p = c.Parameters[j];
                string pName = GetName(p.Name);

                string pre = "";

                if (p.ParamType == ParamType.Out) {
                    pre = "out ";
                } else if (p.ParamType == ParamType.Ref) {
                    pre = "ref ";
                }

                writer.Write("{0}{1}", pre, pName);
                if (j < c.Parameters.Count - 1) {
                    writer.Write(", ");
                }
            }

            writer.WriteLine(");");
        }

        void Patch() {  //some groups are used in the API but are not defined in the <groups> section, they must be added here
            Rename("BlendEquationModeEXT", "BlendEquationMode");  //changes a few names to be more readable
            Rename("BufferTargetARB", "BufferTarget");
            Rename("BlendingFactorSrc", "BlendingFactor");
            Rename("BlendingFactorDest", "BlendingFactor");
            Rename("BlendFuncSeparateParameterEXT", "BlendingFactor");
            Rename("BufferUsageARB", "BufferUsage");
            Rename("ClampColorModeARB", "bool");
            Rename("ClampColorTargetARB", "ClampColorTarget");
            Rename("DrawBufferModeATI", "DrawBufferMode");
            Rename("ColorMaterialFace", "Face");    //these groups are exactly the same, so they all become the same "Face" group
            Rename("MaterialFace", "Face");         //
            Rename("CullFaceMode", "Face");         //
            Rename("StencilFaceDirection", "Face"); //
            Rename("BufferAccessARB", "BufferAccessMask");
            Rename("PointParameterNameARB", "PointParameterName");
            Rename("BufferPNameARB", "BufferPName");
            Rename("BufferPointerNameARB", "BufferPName");
            Rename("VertexAttribPropertyARB", "VertexAttribProperty");
            Rename("VertexAttribPointerPropertyARB", "VertexAttribPointerProperty");

            AddGroup("TypeEnum",  //add in missing groups
                "GL_QUERY_WAIT",            
                "GL_QUERY_NO_WAIT",         
                "GL_QUERY_BY_REGION_WAIT",  
                "GL_QUERY_BY_REGION_NO_WAIT"
            );
            AddGroup("BufferTarget",
                "GL_ARRAY_BUFFER",
                "GL_ATOMIC_COUNTER_BUFFER",
                "GL_COPY_READ_BUFFER",
                "GL_COPY_WRITE_BUFFER",
                "GL_DRAW_INDIRECT_BUFFER",
                "GL_DISPATCH_INDIRECT_BUFFER",
                "GL_ELEMENT_ARRAY_BUFFER",
                "GL_PIXEL_PACK_BUFFER",
                "GL_PIXEL_UNPACK_BUFFER",
                "GL_QUERY_BUFFER",
                "GL_SHADER_STORAGE_BUFFER",
                "GL_TEXTURE_BUFFER",
                "GL_TRANSFORM_FEEDBACK_BUFFER",
                "GL_UNIFORM_BUFFER"
            );
            AddGroup("FramebufferTarget",
                "GL_DRAW_FRAMEBUFFER",
                "GL_READ_FRAMEBUFFER",
                "GL_FRAMEBUFFER"
            );
            AddGroup("RenderbufferTarget", "GL_RENDERBUFFER");
            AddGroup("BlendEquationMode",
                "GL_FUNC_ADD",
                "GL_FUNC_SUBTRACT",
                "GL_FUNC_REVERSE_SUBTRACT",
                "GL_MIN",
                "GL_MAX"
            );
            AddGroup("BufferUsage",
                "GL_STREAM_DRAW",
                "GL_STREAM_READ",
                "GL_STREAM_COPY",
                "GL_STATIC_DRAW",
                "GL_STATIC_READ",
                "GL_STATIC_COPY",
                "GL_DYNAMIC_DRAW",
                "GL_DYNAMIC_READ",
                "GL_DYNAMIC_COPY"
            );
            AddGroup("ClampColorTarget", "GL_CLAMP_READ_COLOR");
            AddGroup("DrawElementsType",
                "GL_UNSIGNED_BYTE",                       
                "GL_UNSIGNED_SHORT",
                "GL_UNSIGNED_INT"
            );
            AddGroup("FramebufferAttachment",
                "GL_COLOR_ATTACHMENT0",
                "GL_COLOR_ATTACHMENT1",
                "GL_COLOR_ATTACHMENT2",
                "GL_COLOR_ATTACHMENT3",
                "GL_COLOR_ATTACHMENT4",
                "GL_COLOR_ATTACHMENT5",
                "GL_COLOR_ATTACHMENT6",
                "GL_COLOR_ATTACHMENT7",
                "GL_COLOR_ATTACHMENT8",
                "GL_COLOR_ATTACHMENT9",
                "GL_COLOR_ATTACHMENT11",
                "GL_COLOR_ATTACHMENT12",
                "GL_COLOR_ATTACHMENT13",
                "GL_COLOR_ATTACHMENT14",
                "GL_COLOR_ATTACHMENT15",
                "GL_COLOR_ATTACHMENT16",
                "GL_COLOR_ATTACHMENT17",
                "GL_COLOR_ATTACHMENT18",
                "GL_COLOR_ATTACHMENT19",
                "GL_COLOR_ATTACHMENT21",
                "GL_COLOR_ATTACHMENT22",
                "GL_COLOR_ATTACHMENT23",
                "GL_COLOR_ATTACHMENT24",
                "GL_COLOR_ATTACHMENT25",
                "GL_COLOR_ATTACHMENT26",
                "GL_COLOR_ATTACHMENT27",
                "GL_COLOR_ATTACHMENT28",
                "GL_COLOR_ATTACHMENT29",
                "GL_COLOR_ATTACHMENT30",
                "GL_COLOR_ATTACHMENT31",
                "GL_DEPTH_ATTACHMENT",
                "GL_STENCIL_ATTACHMENT",
                "GL_DEPTH_STENCIL_ATTACHMENT"
            );
            AddGroup("TextureUnit",
                "GL_TEXTURE0",
                "GL_TEXTURE1",
                "GL_TEXTURE2",
                "GL_TEXTURE3",
                "GL_TEXTURE4",
                "GL_TEXTURE5",
                "GL_TEXTURE6",
                "GL_TEXTURE7",
                "GL_TEXTURE8",
                "GL_TEXTURE9",
                "GL_TEXTURE10",
                "GL_TEXTURE11",
                "GL_TEXTURE12",
                "GL_TEXTURE13",
                "GL_TEXTURE14",
                "GL_TEXTURE15",
                "GL_TEXTURE16",
                "GL_TEXTURE17",
                "GL_TEXTURE18",
                "GL_TEXTURE19",
                "GL_TEXTURE20",
                "GL_TEXTURE21",
                "GL_TEXTURE22",
                "GL_TEXTURE23",
                "GL_TEXTURE24",
                "GL_TEXTURE25",
                "GL_TEXTURE26",
                "GL_TEXTURE27",
                "GL_TEXTURE28",
                "GL_TEXTURE29",
                "GL_TEXTURE30",
                "GL_TEXTURE31"
            );
            AddGroup("PixelInternalFormat",
                "GL_COMPRESSED_RGB8_ETC2",
                "GL_COMPRESSED_SRGB8_ETC2",
                "GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",
                "GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",
                "GL_COMPRESSED_RGBA8_ETC2_EAC",
                "GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",
                "GL_COMPRESSED_R11_EAC",
                "GL_COMPRESSED_SIGNED_R11_EAC",
                "GL_COMPRESSED_RG11_EAC",
                "GL_COMPRESSED_SIGNED_RG11_EAC"
            );
            AddGroup("VertexAttribEnum",
                "GL_BYTE",
                "GL_UNSIGNED_BYTE",
                "GL_SHORT", 
                "GL_UNSIGNED_SHORT",
                "GL_INT",
                "GL_UNSIGNED_INT"
            );
            AddGroup("VertexAttribPointerType",
                "GL_BYTE",
                "GL_UNSIGNED_BYTE",
                "GL_SHORT",
                "GL_UNSIGNED_SHORT",
                "GL_INT",
                "GL_UNSIGNED_INT",
                "GL_HALF_FLOAT",
                "GL_FLOAT",
                "GL_DOUBLE",
                "GL_FIXED",
                "GL_INT_2_10_10_10_REV",
                "GL_UNSIGNED_INT_2_10_10_10_REV",
                "GL_UNSIGNED_INT_10F_11F_11F_REV"
            );
            AddGroup("Face",
                "GL_BACK",
                "GL_FRONT",
                "GL_FRONT_AND_BACK"
            );
            AddGroup("BufferAccess",
                "GL_READ_ONLY",
                "GL_WRITE_ONLY",
                "GL_READ_WRITE"
            );
            AddGroup("PointParameterName",
                "GL_POINT_FADE_THRESHOLD_SIZE",
                "GL_POINT_SPRITE_COORD_ORIGIN"
            );
            AddGroup("BufferPName",
                "GL_BUFFER_ACCESS",
                "GL_BUFFER_ACCESS_FLAGS",
                "GL_BUFFER_IMMUTABLE_STORAGE",
                "GL_BUFFER_MAPPED",
                "GL_BUFFER_MAP_LENGTH",
                "GL_BUFFER_MAP_OFFSET",
                "GL_BUFFER_SIZE",
                "GL_BUFFER_STORAGE_FLAGS",
                "GL_BUFFER_USAGE"
            );
            AddGroup("VertexAttribProperty",
                "GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
                "GL_VERTEX_ATTRIB_ARRAY_ENABLED",
                "GL_VERTEX_ATTRIB_ARRAY_SIZE",
                "GL_VERTEX_ATTRIB_ARRAY_STRIDE",
                "GL_VERTEX_ATTRIB_ARRAY_TYPE",
                "GL_VERTEX_ATTRIB_ARRAY_NORMALIZED",
                "GL_VERTEX_ATTRIB_ARRAY_INTEGER",
                "GL_VERTEX_ATTRIB_ARRAY_DIVISOR",
                "GL_CURRENT_VERTEX_ATTRIB"
            );
            AddGroup("ProgramParameterPName",
                "GL_PROGRAM_BINARY_RETRIEVABLE_HINT",
                "GL_PROGRAM_SEPARABLE"
            );
            AddGroup("GetPointervPName",
                "GL_DEBUG_CALLBACK_FUNCTION",
                "GL_DEBUG_CALLBACK_USER_PARAM"
            );
            AddGroup("VertexAttribPointerProperty",
                "GL_VERTEX_ATTRIB_ARRAY_POINTER"
            );

            AddGroup("DebugMessageSource",
                "GL_DEBUG_SOURCE_API",
                "GL_DEBUG_SOURCE_WINDOW_SYSTEM",
                "GL_DEBUG_SOURCE_SHADER_COMPILER",
                "GL_DEBUG_SOURCE_THIRD_PARTY",
                "GL_DEBUG_SOURCE_APPLICATION",
                "GL_DEBUG_SOURCE_OTHER"
            );
            AddGroup("DebugMessageType",
                "GL_DEBUG_TYPE_ERROR",
                "GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR",
                "GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR",
                "GL_DEBUG_TYPE_PORTABILITY",
                "GL_DEBUG_TYPE_PERFORMANCE",
                "GL_DEBUG_TYPE_MARKER",
                "GL_DEBUG_TYPE_PUSH_GROUP",
                "GL_DEBUG_TYPE_POP_GROUP",
                "GL_DEBUG_TYPE_OTHER"
            );
            AddGroup("DebugMessageSeverity",
                "GL_DEBUG_SEVERITY_HIGH",
                "GL_DEBUG_SEVERITY_MEDIUM",
                "GL_DEBUG_SEVERITY_LOW",
                "GL_DEBUG_SEVERITY_NOTIFICATION"
            );

            AddGroupToCommand("glBeginQuery", "target", "QueryMode");
            AddGroupToCommand("glBeginQueryIndexed", "target", "QueryMode");
            AddGroup("QueryMode",
                "GL_SAMPLES_PASSED",
                "GL_ANY_SAMPLES_PASSED",
                "GL_ANY_SAMPLES_PASSED_CONSERVATIVE",
                "GL_PRIMITIVES_GENERATED",
                "GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",
                "GL_TIME_ELAPSED"
            );

            AddGroupToCommand("glBeginTransformFeedback", "primitiveMode", "TransformFeedbackMode");
            AddGroup("TransformFeedbackMode",
                "GL_POINTS",
                "GL_LINES",
                "GL_TRIANGLES"
            );

            AddGroupToCommand("glBindBufferBase", "target", "BufferTarget");
            AddGroupToCommand("glBindBufferRange", "target", "BufferTarget");
            AddGroupToCommand("glBindBuffersBase", "target", "BufferTarget");
            AddGroupToCommand("glBindBuffersRange", "target", "BufferTarget");

            AddGroupToCommand("glCreateShader", "type", "ShaderType");
            AddGroup("ShaderType",
                "GL_COMPUTE_SHADER",
                "GL_VERTEX_SHADER",
                "GL_TESS_CONTROL_SHADER",
                "GL_TESS_EVALUATION_SHADER",
                "GL_GEOMETRY_SHADER",
                "GL_FRAGMENT_SHADER"
            );

            AddGroupToCommand("glMapNamedBuffer", "access", "BufferAccessMask");
            AddGroupToCommand("glMapNamedBufferRange", "access", "BufferAccessMask");
            AddGroup("BufferAccessMask",
                "GL_MAP_READ_BIT",
                "GL_MAP_WRITE_BIT",
                "GL_MAP_INVALIDATE_RANGE_BIT",
                "GL_MAP_INVALIDATE_BUFFER_BIT",
                "GL_MAP_FLUSH_EXPLICIT_BIT",
                "GL_MAP_UNSYNCHRONIZED_BIT"
            );

            AddGroup("ProgramParameter",
                "GL_DELETE_STATUS",
                "GL_LINK_STATUS",
                "GL_VALIDATE_STATUS",
                "GL_INFO_LOG_LENGTH",
                "GL_ATTACHED_SHADERS",
                "GL_ACTIVE_ATOMIC_COUNTER_BUFFERS",
                "GL_ACTIVE_ATTRIBUTES",
                "GL_ACTIVE_ATTRIBUTE_MAX_LENGTH",
                "GL_ACTIVE_UNIFORMS",
                "GL_ACTIVE_UNIFORM_BLOCKS",
                "GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH",
                "GL_ACTIVE_UNIFORM_MAX_LENGTH",
                "GL_COMPUTE_WORK_GROUP_SIZE",
                "GL_PROGRAM_BINARY_LENGTH",
                "GL_TRANSFORM_FEEDBACK_BUFFER_MODE",
                "GL_TRANSFORM_FEEDBACK_VARYINGS",
                "GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH",
                "GL_GEOMETRY_VERTICES_OUT",
                "GL_GEOMETRY_INPUT_TYPE",
                "GL_GEOMETRY_OUTPUT_TYPE"
            );
            AddGroupToCommand("glGetProgramiv", "pname", "ProgramParameter");

            AddGroup("ShaderParameter",
                "GL_SHADER_TYPE",
                "GL_DELETE_STATUS",
                "GL_COMPILE_STATUS",
                "GL_INFO_LOG_LENGTH",
                "GL_SHADER_SOURCE_LENGTH"
            );
            AddGroupToCommand("glGetShaderiv", "pname", "ShaderParameter");
            AddGroupToCommand("glNamedBufferData", "usage", "BufferUsage");

            ChangeParam("glCreateBuffers", "buffers", ParamType.Array);
            ChangeParam("glCreateFramebuffers", "framebuffers", ParamType.Array);
            ChangeParam("glCreateProgramPipelines", "pipelines", ParamType.Array);
            ChangeParam("glCreateQueries", "ids", ParamType.Array);
            ChangeParam("glCreateRenderbuffers", "renderbuffers", ParamType.Array);
            ChangeParam("glCreateSamplers", "samplers", ParamType.Array);
            ChangeParam("glCreateTextures", "textures", ParamType.Array);
            ChangeParam("glCreateTransformFeedbacks", "ids", ParamType.Array);
            ChangeParam("glCreateVertexArrays", "arrays", ParamType.Array);
            
            AddGroupToCommand("glCreateQueries", "target", "QueryMode");
            AddGroupToCommand("glCreateShaderProgramv", "type", "ShaderType");
            AddGroupToCommand("glCreateTextures", "target", "TextureTarget");

            AddGroupToCommand("glVertexArrayAttribFormat", "type", "VertexAttribPointerType");
            AddGroupToCommand("glVertexArrayAttribIFormat", "type", "VertexAttribPointerType");
            AddGroupToCommand("glVertexArrayAttribLFormat", "type", "VertexAttribPointerType");
            AddGroupToCommand("glVertexAttribFormat", "type", "VertexAttribPointerType");
            AddGroupToCommand("glVertexAttribIFormat", "type", "VertexAttribPointerType");
            AddGroupToCommand("glVertexAttribLFormat", "type", "VertexAttribPointerType");

            AddGroupToCommand("glGetNamedBufferParameteriv", "pname", "BufferPName");
            AddGroupToCommand("glGetNamedBufferParameteri64v", "pname", "BufferPName");
        }

        void AddGroup(string name, params string[] enums) {
            //var g = new Group(name);
            //includedGroups.Add(g);
            //for (int i = 0; i < enums.Length; i++) {
            //    string eName = enums[i];
            //    g.EnumNames.Add(eName);
            //}
            spec.AddEnum(name, enums);
        }

        void Rename(string source, string target) {
            groupRename.Add(source, target);
        }

        void AddGroupToCommand(string commandName, string parameterName, string groupName) {
            var command = spec.CommandMap[commandName];
            command.GetParam(parameterName).Group = groupName;
        }

        void ChangeParam(string commandName, string parameterName,  ParamType type) {
            var command = spec.CommandMap[commandName];
            command.GetParam(parameterName).ParamType = type;
        }

        string ToCamelCase(string input) {
            var builder = new StringBuilder();
            string[] tokens = input.Split('_');
            for (int i = 1; i < tokens.Length; i++) {
                string token = tokens[i];
                bool first = false;
                if (token.Contains("RG")) { //RG RGB RGBA SRGB
                    builder.Append(token);
                    continue;
                }
                for (int j = 0; j < token.Length; j++) {
                    char c = token[j];
                    if (char.IsDigit(c)) {
                        if (i == 1 && j == 0) {
                            builder.Append('_');
                        }
                        builder.Append(c);
                    } else if (char.IsLetter(c)) {
                        if (!first) {
                            builder.Append(char.ToUpper(c));
                            first = true;
                        } else {
                            builder.Append(char.ToLower(c));
                        }
                    }
                }
            }

            return builder.ToString();
        }

        string GetName(string input) {
            switch (input) {
                case "ref":
                    return "_ref";
                case "params":
                    return "_params";
                case "string":
                    return "_string";
                case "base":
                    return "_base";
                default:
                    return input;
            }
        }

        string GetReturnType(string input, CSCommand command) {
            switch (input) {
                case "GLenum":
                    if (command.ReturnGroup != null) {
                        return command.ReturnGroup;
                    } else {
                        return "uint";
                    }
                case "GLsync":
                    return "IntPtr";
                case "GLfloat":
                    return "float";
                case "GLboolean":
                    return "bool";
                case "GLubyte":
                    return "byte";
                case "GLushort":
                    return "ushort";
                case "GLshort":
                    return "short";
                case "GLint":
                    return "int";
                case "GLuint":
                    return "uint";
                case "GLuint64":
                    return "long";
                case "GLbitfield":
                    return "uint";
                default:
                    return input;
            }
        }

        string GetParamType(Parameter p) {
            switch (p.Type) {
                case "GLint":
                    return "int";
                case "GLuint":
                    return "uint";
                case "GLenum":
                    if (p.Group != null) {
                        return p.Group;
                    } else {
                        return "uint";
                    }
                case "GLbitfield":
                    if (p.Group != null) {
                        return p.Group;
                    } else {
                        return "uint";
                    }
                case "GLfloat":
                    return "float";
                case "GLboolean":
                    return "bool";
                case "GLdouble":
                    return "double";
                case "GLsizei":
                    return "int";
                case "GLsync":
                    return "IntPtr";
                case "GLubyte":
                    return "byte";
                case "GLbyte":
                    return "sbyte";
                case "GLushort":
                    return "ushort";
                case "GLshort":
                    return "short";
                case "GLuint64":
                    return "ulong";
                case "GLint64":
                    return "long";
                case "GLchar":
                    return "char";
                case "GLintptr":
                    return "int";
                case "GLsizeiptr":
                    return "int";
                case "GLchar*":
                    return "string";
                case "GLfloat*":
                    return "float*";
                case "GLuint*":
                    return "uint*";
                case "GLint*":
                    return "int*";
                case "GLint64*":
                    return "long*";
                case "GLdouble*":
                    return "double*";
                case "GLintptr*":
                    return "int*";
                case "GLsizei*":
                    return "int*";
                case "GLenum*":
                    return "uint*";
                case "GLboolean*":
                    return "bool*";
                case "GLsizeiptr*":
                    return "int*";
                case "GLubyte*":
                    return "byte*";
                case "GLbyte*":
                    return "sbyte*";
                case "GLshort*":
                    return "short*";
                case "GLushort*":
                    return "ushort*";
                case "GLuint64*":
                    return "ulong*";
                default:
                    return p.Type;
            }
        }
    }
}
